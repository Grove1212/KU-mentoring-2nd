# -*- coding: utf-8 -*-
"""[w5-1]1495_기타리스트.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TAosMnQugyllH_ln9YWjMIQ3Mpt-0LEt
"""

# queue로 품, 근데 시간초과 나와서 쓸 순 없음 (재귀도 마찬가지)
from collections import deque

# 1단계: 입력값 받기
N, S, M = map(int, input().split())
V = list(map(int, input().split()))

# 2단계: 경우의 수 찾기
q = deque()
q.append(S)
level = list(0 for i in range(0, N+1)) # 각 level에 있는 큐 갯수
level[0] = 1
i = 0
result = 0

while q:
    P = q.popleft()
    level[i] -= 1

    # 범위 안에 들어가면 q에 추가, 다음 레벨의 큐 갯수도 추가
    if 0 <= P + V[i] <= M and P + V[i] not in q:
        q.append(P + V[i])
        level[i+1] += 1
    if 0 <= P - V[i] <= M and P - V[i] not in q:
        q.append(P - V[i])
        level[i+1] += 1

    # 해당 레벨의 큐를 다 소진하면 다음 레벨로 이동
    if level[i] == 0:
        i += 1
    if level[i] == 0: # 다음 레벨에 큐가 없으면 마지막 곡을 연주X는 것이므로 result = -1
        result = -1
        break

    # 마지막 레벨 단계까지 오면 q반복 종료
    if i == N:
        break

# 3단계: 최댓값 출력
for i in q:
    if result <= i:
        result = i
print(result)

# 1단계: 입력 받기
n, s, m = map(int, input().split())
v = list(map(int, input().split()))

# 2단계: dp 설정
dp = [[0] * (m+1) for _ in range(n+1)]
dp[0][s] = 1

# 3단계: dp에 값 저장
for i in range(n):
    for j in range(m+1):
        if dp[i][j] == 1:
            # 범위 안에 들어가면 0을 1로 바꿈
            if j+v[i] <= m:
                dp[i+1][j+v[i]] = 1
            if j-v[i] >= 0:
                dp[i+1][j-v[i]] = 1

# 4단계: 결과 출력
result = -1
for i in range(m, -1, -1):
    if dp[n][i]==1: # 가장 큰 값부터 찾으면 출력, 만약 모두 0이면 -1 출력
        result = i
        break
print(result)