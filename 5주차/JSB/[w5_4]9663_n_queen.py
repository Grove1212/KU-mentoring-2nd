# -*- coding: utf-8 -*-
"""[w5-4]9663_N-Queen.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZEx2QK_seiyFL8Ewg2aUQdBSqiteQM9h
"""

# 1단계: 입력받기
N = int(input())    # N x N 행렬의 N개의 퀸

# 2단계: 경우의 수 세기
board = [0] * N     # (row, col)
visited = [False] * N # 해당 depth 방문여부
result = 0

# 2-2단계: 새로운 퀸의 위치가 기존의 퀸과 같은 열 혹은 대각선에 위치해 있는지 체크
def check(n):
    for i in range(n):
        # 같은 열에 위치하거나 대각선에 위치해 있는지 체크
        # (이때 같은 행에 위치했는지는 확인할 필요가 없다.
        # 어차피 nqueen(depth)의 N번 반복에서 하나의 행에 하나의 퀸이 놓여져 있기 때문)
        if (board[n] == board[i]) or (n-i == abs(board[n] - board[i])):
            return False

    return True

# 2-1단계: 재귀로 dfs, 백트래킹 진행
def nqueen(depth):
    global result

    # depth가 N일 때, 모든 퀸을 다 잘 놓은 것
    if depth == N :
        result += 1
        return

      # depth별 반복문, i는 각 depth의 열
    for i in range(N):

        # 해당 depth를 visited 하지 않았을 때
        if visited[i] == False :
            board[depth] = i     # (depth, i)에 퀸 올리기 (여기서 depth는 row, i는 column에 해당)

            if check(depth):
                visited[i] = True
                nqueen(depth + 1)     # 그 다음 열로 넘어감
                visited[i] = False    # 다시 false로 설정해 백트래킹

# 3단계: 결과 확인하기
nqueen(0)
print(result)
# 비고: python으로는 시간초과되어서 pypy로 제출함 좌우대칭 이용하면 시간을 더 줄일 수 있을 것 같음